# プログラム構成

参考サイト：<br>[初心者向けに徹底解説！オブジェクト指向とは？](https://eng-entrance.com/what-oop)<br>[オブジェクト指向によるクラス設計](https://thinkit.co.jp/article/13112)<br>[MVCモデルについて](https://qiita.com/s_emoto/items/975cc38a3e0de462966a)

## はじめに
    本プログラムはC言語でオブジェクト指向的にプログラムを設計する事を目的としており
    各処理をクラス単位のモジュールに分割し、再利用性の高いプログラムを組むことを目標とする。

<br>

## できること、できないこと
    C言語でオブジェクト指向プログラムのどこまでを再現するか、出来る事と出来ない事を始めに決める。

### 出来ること
    ・クラス単位でのモジュール化        ：構造体を用いてクラスを表現する。
    ・クラスに属性と操作を持たせる      ：関数ポインタを用いて構造体に操作を実装する。
    ・クラスの集約（集化、has-aの関係） ：クラスメンバに別のクラスを取り込む。
    ・多態性っぽいもの                  ：クラスの操作を任意の関数で初期化する。

### 出来ないこと
    ・クラスの継承（is-aの関係）        ：工夫をすればC言語でも継承を実現できるが、複雑になるため継承は行わない。
    ・インターフェースの実装            ：継承と同様に複雑さ回避のため。
    ・カプセル化                        ：C言語仕様上、カプセル化は実装できないので諦める。

<br>


## クラス図
    range_class_diagram.pdfを参照。
<br>

## MVCモデル
    本プログラムはMVCモデルパターンに沿って作成されている。
    電子レンジ動作のロジックを担当するModel、
    表示に関する処理を担当するView、
    ユーザー入力及び、ModelとViewに対する制御を担当するControllerから成る。

    以下に各クラスとM、V、Cそれぞれの対応を記載する。
    ・Model：rangeCookModel, rangeMagnetronModel, rangeRelayModel, rangeTimerModel
    ・View：rangeView
    ・Controller：rangeController, rangeKeyController
<br>

## 各クラスの役割
### rangeController
    主にユーザーから見える設定、操作を行う。
    属性
    ・watt          …　電子レンジ出力設定値
    ・timer         …　調理時間設定値
    操作
    ・startup       …　起動処理を行う。
    ・wattSetting   …　電子レンジの出力を設定する。
    ・timerSetting  …　調理時間を設定する。
    ・start         …　調理を開始する。
    ・stop          …　調理完了時の処理。
    ・manager       …　調理工程制御(rangeCookModel)を呼び出す。

### rangeKeyController
    キーボード入力を制御する。
    属性
    ・keyCode       …　入力されたキーコードの値
    操作
    ・scanKey      …　キーボードの入力監視を行う。
    ・getKey       …　キーコードを取得する。

### rangeView
    表示の制御を行う。
    属性
    ・なし
    操作
    ・startUpDisplay    …　起動時の表示を行う。
    ・wattDisplay       …　出力設定時の表示を行う。
    ・timerDisplay      …　調理時間設定時の表示を行う。
    ・startDisplay      …　調理開始時の表示を行う。
    ・stopDisplay       …　調理完了時の表示を行う。
    ・cookTimerDisplay  …　調理中のカウントダウン表示を行う。

### rangeCookModel
    調理工程を制御する。
    属性
    ・state             …　調理工程
    ・cookTimer         …　調理時間（カウント値）
    操作
    ・cookManager       …　調理工程を制御する。以下の状態を持つ。
                                stateStandby：調理スタンバイ
                                stateCook：調理中
                                stateEnd：調理完了
    ・cookStart         …　調理工程を開始する。
    ・getCookTimer      …　調理時間を取得する。

### rangeMagnetronModel
    マグネトロンの駆動を制御する。
    属性
    ・mqOnTime      …　マグネトロンON時間設定値
    ・mqOffTime     …　マグネトロンOFF時間設定値
    ・state         …　マグネトロンON又は、OFFの状態
    ・mqCounter     …　マグネトロンON又は、OFFのカウント値
    操作
    ・manager       …　マグネトロンON、OFF状態を制御する。
    ・init          …　マグネトロン駆動状態を初期化する。
    ・mqStart       …　マグネトロンの駆動時間を設定し、駆動制御を開始する。

### rangeRelayModel
    リレー制御を行う。
    属性
    ・relayState    …　リレーのON、OFF状態
    操作
    ・relayOn       …　リレー状態をONにする。
    ・relayOff      …　リレー状態をOFFにする。

### rangeTimerModel
    制御に関する時間のカウントを行う。
    属性
    ・timer         …　カウント値のアドレス
    ・countEnable   …　カウント許可
    操作
    ・setTimer      …　カウント値に時間をセットする。
    ・initTimer     …　カウント値を初期化する。
    ・countTimer    …　カウントを行う。
<br>

## クラスの実装方法
### クラスの定義
    クラスは構造体（struct）を用いて定義する。
    クラスは以下の3種類のメンバーを持つことができる。
    ・属性（フィールド）：クラスが所有する変数
    ・操作（メソッド）  ：クラスが所有する関数
    ・集約              ：他クラスを集約することができる

### メソッドの定義
    メソッドはまず関数ポインタを宣言し、そのポインタ変数をクラスに格納することで実現する。
    自身が格納されるクラスのポインタをメソッドの第一引数に指定する。

### クラスとメソッド宣言の例
```c
// まずはクラス型をtypedef宣言する
typedef _sampleClass sampleClass_t;

// メソッドを宣言する
typedef void (*method)(sampleClass_t *this, int a);

// クラスを定義する
struct _sampleClass {
    // 属性
    int field;
    // 操作
    method pMethod;
    // 集約
    anotherClass_t anotherClass;
};
```

### クラスの初期化
    以下の様に、まずはメソッドの実体を宣言＆定義する。
    次にクラスの初期値を変数として定義し、属性と操作をコンストラクタ関数で初期化する。
```c
// メソッドの実体を宣言
static void method (sampleClass_t *this, int a);

// クラスの初期値を定義
const sampleClass_t sampleClassInitValue = {
    0,
    &method
};

// メソッドの実体を定義
static void method (sampleClass_t *this, int a)
{
    printf ("field = %d\n", this->field);
}

// コンストラクタで初期化
void sampleClass_Constructor (sampleClass_t *this)
{
    this->field = sampleClassInitValue.field;
    this->pMethod = sampleClassInitValue.pMethod;
}
```
### インスタンスの生成と初期化
    以下のようにインスタンスを生成し、コンストラクタを呼び出して初期化する。
```c
sampleClass_t sampleClass;                  // 生成
sampleClass_Constructor (&sampleClass);     // 初期化
```

### メソッドの呼び出し
    別クラスなどから、以下のようにして呼び出す。
    第一引数には自身のクラスのポインタを渡す。
```c
sampleClass->method (&sampleClass, 1);
```
<br>

## ファイル構成
### ファイルの種類
    クラスは、2つのヘッダファイルと1つのcソースファイルから構成される。
    ・sampleClass.h ：クラス構造体の定義と、コンストラクタ関数の宣言を記述する。
    ・sample.h      ：クラス構造体とメソッドの関数ポインタの宣言を記述する。
                    　その他、列挙型や#define等も記述する。
    ・sample.c      ：クラスの本体を記述する。

### インクルード
    以下の順序でヘッダファイルをインクルードする。
    ① ：sampleClass.hはsample.hをインクルードする。
    ② ：sample.cはsampleClass.hをインクルードする。
    ③ ：別クラスを集約する場合は、sampleClass.hにanotherClass.hをインクルードする。
    ④ ：列挙型やメソッドのみ別クラスで参照したい場合は、sample.hをインクルードする。
![インクルード](include.jpg)
<br>

## おまけ（多態性っぽいもの）
### 多態性っぽいもの
    クラスメンバの初期値を外部から設定するように変更すれば、オブジェクト指向の多態性っぽいものを実現できる。

### 実現方法
    1. まず、メソッドとクラスメンバの初期値(sampleClassInitValue)を2つ以上宣言する。
    2. sampleClassInitValueをヘッダファイルにextern宣言する。
    3. コンストラクタの引数でsampleClassInitValueを受け取るように変更する。
    4. インスタンスの初期化時にsampleClassInitValueをコンストラクタに渡してやる。

```c : sample.c
/* sample.c */
// メソッドを2つ定義する
static void method1 (sampleClass_t *this, int a)
{
    printf ("value = %d\n", (this->field + a));
}

static void method2 (sampleClass_t *this, int a)
{
    printf ("value = %d\n", (this->field * a));
}

// クラスの初期値を2つ定義する
// それぞれ異なるフィールドとメソッドを初期値に指定しておく
const sampleClass_t sampleClassInitValue1 = {
    1,
    &method1
};

const sampleClass_t sampleClassInitValue2 = {
    2,
    &method2
};

// 初期値を引数で受け取るように変更する
void sampleClass_Constructor (sampleClass_t *this, sampleClass_t initValue)
{
    this->field = initValue.field;
    this->pMethod = initValue.pMethod;
}
```

```c : sample.h
/* sample.h */
// 初期値をextern宣言する
extern const sampleClass_t sampleClassInitValue1;
extern const sampleClass_t sampleClassInitValue2;
```

```c : another.c
/* another.c */
// インスタンスの初期化時に異なる初期値を与える
sampleClass_t instance1, instance2;
sampleClass_Constructor (&instance1, sampleClassInitValue1);
sampleClass_Constructor (&instance2, sampleClassInitValue2);

// メソッドを実行する
instance1->field (&instance1, 2);
instance2->field (&instance2, 2);
```
実行結果
```shell
value = 3
value = 4
```